/* eslint-disable regexp/no-super-linear-backtracking */
/**
 * Module for processing conditional directives (@if, @elseif, @else, @unless)
 */

import process from 'node:process'
import { evaluateAuthExpression } from './auth'
import { createDetailedErrorMessage } from './utils'

/**
 * Process conditionals (@if, @elseif, @else, @unless)
 */
export function processConditionals(template: string, context: Record<string, any>, filePath: string): string {
  let output = template

  // Process @unless directives (convert to @if negation)
  output = output.replace(/@unless\s*\(([^)]+)\)([\s\S]*?)@endunless/g, (_, condition, content) => {
    return `@if (!(${condition}))${content}@endif`
  })

  // Process @isset and @empty directives separately
  output = processIssetEmptyDirectives(output, context, filePath)

  // Process @env directives separately
  output = processEnvDirective(output, context, filePath)

  // Process @auth and @guest directives separately
  output = processAuthDirectives(output, context)

  // Process @if, @else, @elseif directives
  const processIfStatements = () => {
    let hasMatches = false

    output = output.replace(/@if\s*\(([^)]+)\)([\s\S]*?)@endif/g, (match, condition, content, offset) => {
      hasMatches = true

      try {
        // eslint-disable-next-line no-new-func
        const conditionFn = new Function(...Object.keys(context), `return ${condition}`)
        const result = conditionFn(...Object.values(context))

        if (result) {
          // If the condition is true, check for else parts
          const elseParts = content.split(/@else(?:if\s*\([^)]+\))?/)
          return elseParts[0] // Return only the if part
        }
        else {
          // The condition is false, look for else or elseif parts
          const elseifMatches = content.match(/@elseif\s*\(([^)]+)\)([\s\S]*?)(?:@elseif|@else|$)/)
          if (elseifMatches) {
            try {
              // eslint-disable-next-line no-new-func
              const elseifFn = new Function(...Object.keys(context), `return ${elseifMatches[1]}`)
              if (elseifFn(...Object.values(context))) {
                return elseifMatches[2]
              }
            }
            catch (error: any) {
              return createDetailedErrorMessage(
                'Directive',
                `Error in @elseif(${elseifMatches[1]}): ${error instanceof Error ? error.message : String(error)}`,
                filePath,
                template,
                offset + match.indexOf('@elseif'),
                `@elseif(${elseifMatches[1]})`,
              )
            }
          }

          // Check for simple @else
          const elseMatch = content.match(/@else([\s\S]*?)(?:@elseif|$)/)
          if (elseMatch) {
            return elseMatch[1]
          }

          return '' // If no else/elseif or all conditions are false
        }
      }
      catch (error: any) {
        return createDetailedErrorMessage(
          'Directive',
          `Error in @if(${condition}): ${error instanceof Error ? error.message : String(error)}`,
          filePath,
          template,
          offset,
          `@if(${condition})`,
        )
      }
    })

    return hasMatches
  }

  // Process @if statements until no more matches are found
  // This handles nested conditionals
  while (processIfStatements()) {
    // Continue processing until no more @if tags are found
  }

  return output
}

/**
 * Process @auth and permissions directives
 */
export function processAuthDirectives(template: string, context: Record<string, any>): string {
  let output = template

  // Process @auth/@endauth directive
  output = output.replace(
    /@auth\s*(?:\((.*?)\)\s*)?\n([\s\S]*?)(?:@else\s*\n([\s\S]*?))?@endauth/g,
    (_, guard, content, elseContent) => {
      const isAuthenticated = guard
        ? evaluateAuthExpression(`auth?.check && auth?.user?.[${guard}]`, context)
        : evaluateAuthExpression('auth?.check', context)

      return isAuthenticated
        ? content
        : (elseContent || '')
    },
  )

  // Process @guest/@endguest directive
  output = output.replace(
    /@guest\s*(?:\((.*?)\)\s*)?\n([\s\S]*?)(?:@else\s*\n([\s\S]*?))?@endguest/g,
    (_, guard, content, elseContent) => {
      const isGuest = guard
        ? evaluateAuthExpression(`!auth?.check || !auth?.user?.[${guard}]`, context)
        : evaluateAuthExpression('!auth?.check', context)

      return isGuest
        ? content
        : (elseContent || '')
    },
  )

  // Process @can/@endcan directive with all variations
  output = output.replace(
    /@can\('([^']*)'(?:,\s*'([^']*)')?(?:,\s*([^)]*))?\)\s*\n([\s\S]*?)(?:@elsecan\('([^']*)'(?:,\s*'([^']*)')?(?:,\s*([^)]*))?\)\s*\n([\s\S]*?))?(?:@else\s*\n([\s\S]*?))?@endcan/g,
    (_, ability, type, id, content, elseAbility, elseType, elseId, elseContent, finalElseContent) => {
      // Handle permissions with complex evaluation
      let can = false

      // Try different permission checking patterns
      if (context.userCan && typeof context.userCan[ability] === 'boolean') {
        can = context.userCan[ability]
      }
      else if (context.permissions?.check && typeof context.permissions.check === 'function') {
        try {
          const args = [ability]
          if (type)
            args.push(type)
          if (id) {
            // Evaluate id if it's an expression
            const idValue = evaluateAuthExpression(id, context)
            args.push(idValue)
          }
          can = context.permissions.check(...args)
        }
        catch {
          can = false
        }
      }

      if (can) {
        return content
      }
      else if (elseAbility) {
        // Check the elsecan condition
        let elseCan = false

        if (context.userCan && typeof context.userCan[elseAbility] === 'boolean') {
          elseCan = context.userCan[elseAbility]
        }
        else if (context.permissions?.check && typeof context.permissions.check === 'function') {
          try {
            const args = [elseAbility]
            if (elseType)
              args.push(elseType)
            if (elseId) {
              const elseIdValue = evaluateAuthExpression(elseId, context)
              args.push(elseIdValue)
            }
            elseCan = context.permissions.check(...args)
          }
          catch {
            elseCan = false
          }
        }

        return elseCan ? elseContent : (finalElseContent || '')
      }
      else {
        return finalElseContent || ''
      }
    },
  )

  // Process @cannot/@endcannot directive with all variations
  output = output.replace(
    /@cannot\('([^']*)'(?:,\s*'([^']*)')?(?:,\s*([^)]*))?\)\s*\n([\s\S]*?)(?:@elsecannot\('([^']*)'(?:,\s*'([^']*)')?(?:,\s*([^)]*))?\)\s*\n([\s\S]*?))?(?:@else\s*\n([\s\S]*?))?@endcannot/g,
    (_, ability, type, id, content, elseAbility, elseType, elseId, elseContent, finalElseContent) => {
      // Handle permissions with complex evaluation
      let cannot = true

      // Try different permission checking patterns
      if (context.userCan && typeof context.userCan[ability] === 'boolean') {
        cannot = !context.userCan[ability]
      }
      else if (context.permissions?.check && typeof context.permissions.check === 'function') {
        try {
          const args = [ability]
          if (type)
            args.push(type)
          if (id) {
            // Evaluate id if it's an expression
            const idValue = evaluateAuthExpression(id, context)
            args.push(idValue)
          }
          cannot = !context.permissions.check(...args)
        }
        catch {
          cannot = true
        }
      }

      if (cannot) {
        return content
      }
      else if (elseAbility) {
        // Check the elsecannot condition
        let elseCannot = true

        if (context.userCan && typeof context.userCan[elseAbility] === 'boolean') {
          elseCannot = !context.userCan[elseAbility]
        }
        else if (context.permissions?.check && typeof context.permissions.check === 'function') {
          try {
            const args = [elseAbility]
            if (elseType)
              args.push(elseType)
            if (elseId) {
              const elseIdValue = evaluateAuthExpression(elseId, context)
              args.push(elseIdValue)
            }
            elseCannot = !context.permissions.check(...args)
          }
          catch {
            elseCannot = true
          }
        }

        return elseCannot ? elseContent : (finalElseContent || '')
      }
      else {
        return finalElseContent || ''
      }
    },
  )

  return output
}

/**
 * Process @isset and @empty directives
 */
export function processIssetEmptyDirectives(template: string, context: Record<string, any>, filePath?: string): string {
  let result = template

  // Process @isset directive
  result = result.replace(/@isset\(([^)]+)\)((?:.|\n)*?)(?:@else((?:.|\n)*?))?@endisset/g, (match, variable, content, elseContent, offset) => {
    try {
      // Evaluate the variable path (silently handle undefined variables)
      const value = evaluateAuthExpression(variable.trim(), context)

      // Check if it's defined and not null
      if (value !== undefined && value !== null) {
        return content
      }

      return elseContent || ''
    }
    catch (error: any) {
      if (filePath) {
        return createDetailedErrorMessage(
          'Directive',
          `Error processing @isset directive: ${error.message}`,
          filePath,
          template,
          offset,
          match,
        )
      }
      else {
        console.error(`Error processing @isset directive:`, error)
        return match // Return unchanged if error
      }
    }
  })

  // Process @empty directive
  result = result.replace(/@empty\(([^)]+)\)((?:.|\n)*?)(?:@else((?:.|\n)*?))?@endempty/g, (match, variable, content, elseContent, offset) => {
    try {
      // Evaluate the variable path (silently handle undefined variables)
      const value = evaluateAuthExpression(variable.trim(), context)

      // Check if it's empty
      const isEmpty = value === undefined || value === null || value === ''
        || (Array.isArray(value) && value.length === 0)
        || (typeof value === 'object' && value !== null && Object.keys(value).length === 0)

      if (isEmpty) {
        return content
      }

      return elseContent || ''
    }
    catch (error: any) {
      if (filePath) {
        return createDetailedErrorMessage(
          'Directive',
          `Error processing @empty directive: ${error.message}`,
          filePath,
          template,
          offset,
          match,
        )
      }
      else {
        console.error(`Error processing @empty directive:`, error)
        return match // Return unchanged if error
      }
    }
  })

  return result
}

/**
 * Process @env directive to conditionally render content based on environment
 */
export function processEnvDirective(template: string, _context: Record<string, any>, _filePath?: string): string {
  let output = template

  // General @env directive
  output = output.replace(
    /@env\s*\(\s*(['"])([^'"]+)\1\s*\)([\s\S]*?)(?:@else([\s\S]*?))?@endenv/g,
    (_, quote, env, content, elseContent = '') => {
      const currentEnv = process.env.NODE_ENV || process.env.BUN_ENV || 'development'
      return currentEnv === env ? content : elseContent
    },
  )

  // @production directive - renders content only in production environment
  output = output.replace(
    /@production([\s\S]*?)(?:@else([\s\S]*?))?@endproduction/g,
    (_, content, elseContent = '') => {
      const currentEnv = process.env.NODE_ENV || process.env.BUN_ENV || 'development'
      return currentEnv === 'production' ? content : elseContent
    },
  )

  // @development directive - renders content only in development environment
  output = output.replace(
    /@development([\s\S]*?)(?:@else([\s\S]*?))?@enddevelopment/g,
    (_, content, elseContent = '') => {
      const currentEnv = process.env.NODE_ENV || process.env.BUN_ENV || 'development'
      return currentEnv === 'development' ? content : elseContent
    },
  )

  // @staging directive - renders content only in staging environment
  output = output.replace(
    /@staging([\s\S]*?)(?:@else([\s\S]*?))?@endstaging/g,
    (_, content, elseContent = '') => {
      const currentEnv = process.env.NODE_ENV || process.env.BUN_ENV || 'development'
      return currentEnv === 'staging' ? content : elseContent
    },
  )

  // @testing directive - renders content only in testing environment
  output = output.replace(
    /@testing([\s\S]*?)(?:@else([\s\S]*?))?@endtesting/g,
    (_, content, elseContent = '') => {
      const currentEnv = process.env.NODE_ENV || process.env.BUN_ENV || 'development'
      return currentEnv === 'testing' ? content : elseContent
    },
  )

  return output
}
