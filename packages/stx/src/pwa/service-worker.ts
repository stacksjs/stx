/**
 * PWA Service Worker Generation
 *
 * Generates a service worker JavaScript file with configurable caching strategies.
 * Supports: cache-first, network-first, stale-while-revalidate, network-only, cache-only
 */

import type { StxOptions } from '../types'

/**
 * Generate the service worker JavaScript code
 */
export function generateServiceWorker(options: StxOptions): string {
  const pwa = options.pwa
  if (!pwa?.enabled) {
    return ''
  }

  const swConfig = pwa.serviceWorker || {}
  const routes = pwa.routes || []
  const cacheVersion = swConfig.cacheVersion || '1.0.0'
  const offlineConfig = pwa.offline
  const offlinePage = offlineConfig?.page ? '/offline.html' : '/offline.html'

  const precacheAssets = [
    '/',
    '/manifest.json',
    ...(offlineConfig?.enabled ? [offlinePage] : []),
    ...(offlineConfig?.precacheAssets || []),
  ]

  return `/**
 * Service Worker - Auto-generated by stx
 * Cache Version: ${cacheVersion}
 *
 * This service worker implements configurable caching strategies:
 * - cache-first: Serve from cache, fall back to network
 * - network-first: Try network, fall back to cache
 * - stale-while-revalidate: Serve cached, update in background
 * - network-only: Always fetch from network
 * - cache-only: Only serve from cache
 */

const CACHE_VERSION = '${cacheVersion}';
const CACHE_NAME = 'stx-pwa-v' + CACHE_VERSION;
const OFFLINE_PAGE = '${offlinePage}';

// Assets to precache on install
const PRECACHE_ASSETS = ${JSON.stringify(precacheAssets, null, 2)};

// Route caching strategies
const ROUTE_STRATEGIES = ${JSON.stringify(routes, null, 2)};

// Routes to exclude from caching
const EXCLUDED_ROUTES = ${JSON.stringify(swConfig.excludeRoutes || [], null, 2)};

/**
 * Install event - precache essential assets
 */
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');
  ${swConfig.skipWaiting ? 'self.skipWaiting();' : ''}

  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('[SW] Precaching assets:', PRECACHE_ASSETS.length);
      return cache.addAll(PRECACHE_ASSETS).catch((error) => {
        console.warn('[SW] Failed to precache some assets:', error);
        // Continue even if some assets fail to cache
        return Promise.resolve();
      });
    })
  );
});

/**
 * Activate event - clean up old caches
 */
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  ${swConfig.clientsClaim ? 'self.clients.claim();' : ''}

  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name.startsWith('stx-pwa-') && name !== CACHE_NAME)
          .map((name) => {
            console.log('[SW] Deleting old cache:', name);
            return caches.delete(name);
          })
      );
    })
  );
});

/**
 * Fetch event - apply caching strategies
 */
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Only handle GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Skip cross-origin requests
  if (url.origin !== location.origin) {
    return;
  }

  // Skip excluded routes
  if (isExcludedRoute(url.pathname)) {
    return;
  }

  // Find matching strategy and apply
  const routeConfig = getRouteConfig(url.pathname);
  event.respondWith(applyStrategy(request, routeConfig));
});

/**
 * Check if a route should be excluded from caching
 */
function isExcludedRoute(pathname) {
  return EXCLUDED_ROUTES.some((pattern) => matchPattern(pathname, pattern));
}

/**
 * Match a path against a glob pattern
 * Supports: *.ext, /path/*, /path/**, exact matches
 */
function matchPattern(path, pattern) {
  // Handle file extension patterns like *.js, *.css
  if (pattern.startsWith('*.')) {
    return path.endsWith(pattern.slice(1));
  }

  // Handle patterns ending with /**
  if (pattern.endsWith('/**')) {
    const prefix = pattern.slice(0, -3);
    return path.startsWith(prefix);
  }

  // Handle patterns ending with /*
  if (pattern.endsWith('/*')) {
    const prefix = pattern.slice(0, -2);
    if (!path.startsWith(prefix)) return false;
    const rest = path.slice(prefix.length);
    return rest.length > 0 && !rest.slice(1).includes('/');
  }

  // Handle patterns with * in the middle
  if (pattern.includes('*')) {
    const parts = pattern.split('*');
    if (parts.length === 2) {
      return path.startsWith(parts[0]) && path.endsWith(parts[1]);
    }
  }

  // Exact match
  return path === pattern;
}

/**
 * Get the cache configuration for a given path
 */
function getRouteConfig(pathname) {
  for (const route of ROUTE_STRATEGIES) {
    if (matchPattern(pathname, route.pattern)) {
      return route;
    }
  }
  // Default to network-first for unmatched routes
  return { strategy: 'network-first' };
}

/**
 * Apply the appropriate caching strategy
 */
async function applyStrategy(request, routeConfig) {
  const { strategy, cacheName, maxAgeSeconds, maxEntries } = routeConfig;
  const cache = await caches.open(cacheName || CACHE_NAME);

  switch (strategy) {
    case 'cache-first':
      return cacheFirst(request, cache, maxAgeSeconds);

    case 'network-first':
      return networkFirst(request, cache);

    case 'stale-while-revalidate':
      return staleWhileRevalidate(request, cache);

    case 'network-only':
      return networkOnly(request);

    case 'cache-only':
      return cacheOnly(request, cache);

    default:
      return networkFirst(request, cache);
  }
}

/**
 * Cache-first strategy
 * Serve from cache if available, otherwise fetch from network
 */
async function cacheFirst(request, cache, maxAge) {
  const cached = await cache.match(request);

  if (cached) {
    // Check if cache is still valid (if maxAge is set)
    if (maxAge) {
      const cachedDate = cached.headers.get('sw-cache-date');
      if (cachedDate) {
        const age = (Date.now() - new Date(cachedDate).getTime()) / 1000;
        if (age > maxAge) {
          // Cache expired, fetch fresh
          return fetchAndCache(request, cache);
        }
      }
    }
    return cached;
  }

  return fetchAndCache(request, cache);
}

/**
 * Network-first strategy
 * Try network first, fall back to cache if offline
 */
async function networkFirst(request, cache) {
  try {
    const response = await fetch(request);
    if (response.ok) {
      const cloned = response.clone();
      cache.put(request, cloned);
    }
    return response;
  } catch (error) {
    const cached = await cache.match(request);
    if (cached) {
      return cached;
    }
    return offlineResponse(request);
  }
}

/**
 * Stale-while-revalidate strategy
 * Serve cached immediately, update cache in background
 */
async function staleWhileRevalidate(request, cache) {
  const cached = await cache.match(request);

  // Fetch in background to update cache
  const fetchPromise = fetch(request)
    .then((response) => {
      if (response.ok) {
        cache.put(request, response.clone());
      }
      return response;
    })
    .catch(() => null);

  // Return cached immediately if available, otherwise wait for fetch
  if (cached) {
    return cached;
  }

  const response = await fetchPromise;
  return response || offlineResponse(request);
}

/**
 * Network-only strategy
 * Always fetch from network, no caching
 */
async function networkOnly(request) {
  try {
    return await fetch(request);
  } catch (error) {
    return offlineResponse(request);
  }
}

/**
 * Cache-only strategy
 * Only serve from cache, never fetch
 */
async function cacheOnly(request, cache) {
  const cached = await cache.match(request);
  return cached || offlineResponse(request);
}

/**
 * Fetch and cache a request
 */
async function fetchAndCache(request, cache) {
  try {
    const response = await fetch(request);
    if (response.ok) {
      // Add cache timestamp header
      const headers = new Headers(response.headers);
      headers.set('sw-cache-date', new Date().toISOString());

      const cachedResponse = new Response(response.clone().body, {
        status: response.status,
        statusText: response.statusText,
        headers,
      });

      cache.put(request, cachedResponse);
    }
    return response;
  } catch (error) {
    return offlineResponse(request);
  }
}

/**
 * Generate offline response
 */
async function offlineResponse(request) {
  // For navigation requests, return offline page
  if (request.mode === 'navigate') {
    const cache = await caches.open(CACHE_NAME);
    const offlinePage = await cache.match(OFFLINE_PAGE);
    if (offlinePage) {
      return offlinePage;
    }
  }

  // Return a basic offline response
  return new Response('You are offline', {
    status: 503,
    statusText: 'Service Unavailable',
    headers: {
      'Content-Type': 'text/plain',
    },
  });
}

console.log('[SW] Service Worker loaded - Version:', CACHE_VERSION);
`
}

/**
 * Get the service worker file name from config
 */
export function getServiceWorkerFileName(options: StxOptions): string {
  return options.pwa?.serviceWorker?.fileName || 'sw.js'
}
