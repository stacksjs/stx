<script>
// Server-side: Static data available at build time
export const title = 'Voide'
export const version = '1.0.0'
export const apiBaseUrl = 'http://localhost:3008/voide'

export const drivers = {
  'claude-cli-local': { name: 'Claude CLI (Local)', requiresKey: null },
  'claude-cli-ec2': { name: 'Claude CLI (EC2)', requiresKey: 'BUDDY_EC2_HOST' },
  'claude': { name: 'Claude API', requiresKey: 'ANTHROPIC_API_KEY' },
  'openai': { name: 'OpenAI', requiresKey: 'OPENAI_API_KEY' },
  'ollama': { name: 'Ollama', requiresKey: null },
  'mock': { name: 'Mock', requiresKey: null }
}
</script>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>{{ title }} - Voice AI Code Assistant</title>

  <style>
    /* Custom animations not in Headwind */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(233, 69, 96, 0.4); }
      50% { box-shadow: 0 0 0 20px rgba(233, 69, 96, 0); }
    }
    @keyframes bounce {
      to { transform: translateY(-8px); }
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .animate-fade-in { animation: fadeIn 0.3s ease; }
    .animate-pulse { animation: pulse 1.5s infinite; }
    .animate-bounce { animation: bounce 0.6s infinite alternate; }
    .animate-blink { animation: blink 1s step-end infinite; }

    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #0f0f23; }
    ::-webkit-scrollbar-thumb { background: #2d2d4a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #666; }

    /* Body styling */
    body {
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      background: #1a1a2e;
      color: #eaeaea;
    }

  </style>

  <!-- Load Headwind CSS -->
  <script>
    // Dynamically load Headwind CSS to bypass bundler
    (function() {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = '/dist/voide.css';
      link.onload = function() { document.body.style.visibility = 'visible'; };
      document.head.appendChild(link);
      // Hide body until CSS loads to prevent FOUC
      document.write('<style>body{visibility:hidden}</style>');
    })();
  </script>
</head>
<body class="flex flex-col h-screen">
  <!-- Header -->
  @include('./components/voide/header', { title })

  <!-- Main Content -->
  <main class="flex-1 flex flex-col p-5 gap-5 overflow-hidden">
    <!-- Terminal -->
    @include('./components/voide/terminal')

    <!-- Input Bar -->
    @include('./components/voide/input-bar')
  </main>

  <!-- Footer -->
  <footer id="footer" class="px-5 py-2.5 text-center text-[11px] text-[#666] border-t border-[#2d2d4a]">
    {{ title }} v{{ version }} - Voice AI Code Assistant
  </footer>

  <!-- Modals -->
  @include('./components/voide/modals')

  <!-- Craft Native Bridge -->
  <script>
    (function() {
      if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.craftBridge) {
        window.craft = {
          _callbacks: {},
          _callbackId: 0,
          _invoke: function(method, args) {
            args = args || {};
            var self = this;
            return new Promise(function(resolve, reject) {
              var id = ++self._callbackId;
              self._callbacks[id] = { resolve: resolve, reject: reject };
              window.webkit.messageHandlers.craftBridge.postMessage({ id: id, method: method, args: args });
            });
          },
          _handleResponse: function(id, result, error) {
            var cb = this._callbacks[id];
            if (cb) {
              delete this._callbacks[id];
              error ? cb.reject(new Error(error)) : cb.resolve(result);
            }
          },
          window: {
            setTitle: function(title) { return window.craft._invoke('window.setTitle', { title: title }); },
            close: function() { return window.craft._invoke('window.close'); },
            minimize: function() { return window.craft._invoke('window.minimize'); },
            maximize: function() { return window.craft._invoke('window.maximize'); }
          },
          tray: {
            setTitle: function(title) { return window.craft._invoke('tray.setTitle', { title: title }); },
            setTooltip: function(tooltip) { return window.craft._invoke('tray.setTooltip', { tooltip: tooltip }); },
            setMenu: function(menu) { return window.craft._invoke('tray.setMenu', { menu: menu }); },
            onClickToggleWindow: function() { return window.craft._invoke('tray.onClickToggleWindow'); }
          },
          app: {
            quit: function() { return window.craft._invoke('app.quit'); },
            notify: function(options) { return window.craft._invoke('app.notify', options); }
          }
        };
        console.log('[Voide] Craft native bridge initialized');
      }
    })();
  </script>

  <!-- STX Client Runtime -->
  <script client>
    import { ref, reactive, computed, onMounted, onUnmounted, watch } from 'stx'

    // ==========================================================================
    // Reactive State
    // ==========================================================================

    const state = reactive({
      isRecording: false,
      isProcessing: false,
      transcript: '',
      repoPath: '',
      hasChanges: false,
      speechSupported: false,
      currentDriver: 'claude-cli-local',
      isNativeApp: false,
      terminalTitle: 'Voide - Ready'
    })

    const messages = ref([])
    const message = ref('')
    const charCount = ref(0)

    const github = reactive({
      connected: false,
      token: null,
      username: null,
      name: null,
      email: null,
      avatarUrl: null
    })

    const apiKeys = reactive({
      anthropic: null,
      openai: null,
      claudeCliHost: null
    })

    const modals = reactive({
      github: false,
      settings: false
    })

    // Speech recognition instance
    let recognition = null

    // Config
    const config = {
      title: 'Voide',
      version: '1.0.0',
      apiBaseUrl: 'http://localhost:3008/voide',
      drivers: {
        'claude-cli-local': { name: 'Claude CLI (Local)', requiresKey: null },
        'claude-cli-ec2': { name: 'Claude CLI (EC2)', requiresKey: 'BUDDY_EC2_HOST' },
        'claude': { name: 'Claude API', requiresKey: 'ANTHROPIC_API_KEY' },
        'openai': { name: 'OpenAI', requiresKey: 'OPENAI_API_KEY' },
        'ollama': { name: 'Ollama', requiresKey: null },
        'mock': { name: 'Mock', requiresKey: null }
      }
    }

    const STORAGE_KEY_REPO = 'voide_last_repo_path'

    // ==========================================================================
    // Computed Properties
    // ==========================================================================

    const currentDriverName = computed(() => {
      return config.drivers[state.currentDriver]?.name || 'AI'
    })

    const canCommit = computed(() => {
      return state.hasChanges && !state.isProcessing
    })

    const canPush = computed(() => {
      return state.hasChanges && !state.isProcessing
    })

    // ==========================================================================
    // Methods
    // ==========================================================================

    function escapeHtml(text) {
      const div = document.createElement('div')
      div.textContent = text
      return div.innerHTML
    }

    function addMessage(type, content, header) {
      const driverName = currentDriverName.value
      const headerText = header || (type === 'user' ? 'You' : type === 'assistant' ? driverName : type === 'system' ? 'System' : 'Error')

      messages.value.push({
        type,
        content,
        header: headerText,
        timestamp: Date.now()
      })

      // Scroll to bottom
      setTimeout(() => {
        const output = document.getElementById('output')
        if (output) output.scrollTop = output.scrollHeight
      }, 10)
    }

    async function checkBackendAPI() {
      try {
        const res = await fetch(config.apiBaseUrl + '/state')
        return res.ok
      } catch {
        return false
      }
    }

    async function processCommand(command) {
      if (!command.trim()) return

      addMessage('user', command)
      state.terminalTitle = 'Processing...'

      if (!state.repoPath) {
        addMessage('error', 'Please enter a repository URL or path first.')
        state.terminalTitle = config.title + ' - Ready'
        return
      }

      state.isProcessing = true
      addMessage('assistant', '...')  // Loading indicator

      try {
        const hasBackend = await checkBackendAPI()
        let response

        if (hasBackend) {
          const res = await fetch(config.apiBaseUrl + '/process', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              command,
              driver: state.currentDriver,
              repository: state.repoPath
            })
          })
          response = await res.json()
        } else if (state.currentDriver === 'mock') {
          await new Promise(resolve => setTimeout(resolve, 1500))
          response = {
            success: true,
            data: {
              message: `[Mock] Processing: "${command}"\n\nThis is a simulated response.`,
              hasChanges: command.toLowerCase().includes('fix')
            }
          }
        } else {
          throw new Error('Backend API not available. Start the server at localhost:3008.')
        }

        // Remove loading message
        messages.value.pop()

        if (response.success && response.data) {
          addMessage('assistant', response.data.message)
          if (response.data.hasChanges) {
            state.hasChanges = true
            addMessage('system', 'Changes staged. Click "Commit Changes" to create a commit.')
            sendNotification('Changes Ready', 'Code changes are staged.')
          }
        } else {
          throw new Error(response.error || 'Unknown error')
        }

        state.terminalTitle = config.title + ' - Ready'
        updateTrayStatus('success')
        setTimeout(() => updateTrayStatus('ready'), 2000)

      } catch (error) {
        messages.value.pop()  // Remove loading
        addMessage('error', 'Failed: ' + error.message)
        state.terminalTitle = config.title + ' - Error'
        updateTrayStatus('error')
        setTimeout(() => updateTrayStatus('ready'), 3000)
      } finally {
        state.isProcessing = false
      }
    }

    async function handleRepoAction() {
      const input = document.getElementById('repoInput')?.value.trim()
      if (!input) {
        addMessage('error', 'Please enter a repository URL or path.')
        return
      }

      addMessage('system', 'Opening repository: ' + input)

      try {
        const hasBackend = await checkBackendAPI()
        let response

        if (hasBackend) {
          const res = await fetch(config.apiBaseUrl + '/repo', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input })
          })
          response = await res.json()
        } else {
          response = {
            success: true,
            data: {
              repo: { path: input, name: input.split('/').pop(), branch: 'main' }
            }
          }
        }

        if (response.success && response.data?.repo) {
          const repo = response.data.repo
          state.repoPath = repo.path
          localStorage.setItem(STORAGE_KEY_REPO, repo.path)
          addMessage('system', `Repository "${repo.name}" opened.\nPath: ${repo.path}\nBranch: ${repo.branch}`)
          state.terminalTitle = config.title + ' - ' + repo.name
        } else {
          throw new Error(response.error || 'Failed to open repository')
        }
      } catch (error) {
        addMessage('error', 'Failed: ' + error.message)
      }
    }

    async function commitChanges() {
      if (!state.hasChanges) return

      addMessage('system', 'Creating commit...')
      updateTrayStatus('processing')

      try {
        const hasBackend = await checkBackendAPI()
        let response

        if (hasBackend) {
          const res = await fetch(config.apiBaseUrl + '/commit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
          response = await res.json()
        } else {
          response = { success: true, hash: 'mock-commit-hash' }
        }

        addMessage('system', 'Committed: ' + (response.hash || 'success'))
        state.hasChanges = false
        updateTrayStatus('success')
        setTimeout(() => updateTrayStatus('ready'), 2000)
      } catch (error) {
        addMessage('error', 'Failed: ' + error.message)
        updateTrayStatus('error')
        setTimeout(() => updateTrayStatus('ready'), 3000)
      }
    }

    async function pushChanges() {
      addMessage('system', 'Pushing to remote...')
      updateTrayStatus('processing')

      try {
        const hasBackend = await checkBackendAPI()
        if (hasBackend) {
          await fetch(config.apiBaseUrl + '/push', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
        }

        addMessage('system', 'Pushed successfully.')
        updateTrayStatus('success')
        setTimeout(() => updateTrayStatus('ready'), 2000)
      } catch (error) {
        addMessage('error', 'Failed: ' + error.message)
        updateTrayStatus('error')
        setTimeout(() => updateTrayStatus('ready'), 3000)
      }
    }

    // ==========================================================================
    // Speech Recognition
    // ==========================================================================

    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition
      if (!SpeechRecognition) {
        state.speechSupported = false
        addMessage('system', 'Speech recognition not available. Please use text input.')
        return false
      }

      recognition = new SpeechRecognition()
      recognition.continuous = false
      recognition.interimResults = true
      recognition.lang = 'en-US'
      recognition.maxAlternatives = 1

      recognition.onstart = () => {
        state.isRecording = true
        state.transcript = ''
        updateTrayStatus('recording')
      }

      recognition.onresult = (event) => {
        let transcript = ''
        for (let i = 0; i < event.results.length; i++) {
          transcript += event.results[i][0].transcript
        }
        state.transcript = transcript
      }

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error)
        stopRecording()
        if (event.error === 'not-allowed') {
          addMessage('error', 'Microphone access denied.')
        } else if (event.error === 'network') {
          addMessage('error', 'Speech recognition requires internet.')
        } else if (event.error !== 'aborted' && event.error !== 'no-speech') {
          addMessage('error', 'Speech error: ' + event.error)
        }
      }

      recognition.onend = () => {
        if (state.isRecording) {
          const transcript = state.transcript.trim()
          stopRecording()
          if (transcript) processCommand(transcript)
        }
      }

      state.speechSupported = true
      return true
    }

    function startRecording() {
      if (!state.speechSupported || state.isRecording) return
      state.transcript = ''
      try {
        recognition.start()
      } catch (e) {
        addMessage('error', 'Failed to start voice recognition.')
      }
    }

    function stopRecording() {
      state.isRecording = false
      updateTrayStatus('ready')
      if (recognition) {
        try { recognition.stop() } catch (e) {}
      }
    }

    // ==========================================================================
    // Native App Features
    // ==========================================================================

    function initNativeFeatures() {
      if (!window.craft) return

      state.isNativeApp = true
      try {
        window.craft.tray.setTitle('Voide')
        window.craft.tray.setTooltip('Voide - Voice AI Code Assistant')
        window.craft.tray.setMenu([
          { id: 'show', label: 'Show Voide', action: 'show' },
          { id: 'hide', label: 'Hide Window', action: 'hide' },
          { type: 'separator' },
          { id: 'recording', label: 'Start Recording', action: 'startRecording' },
          { type: 'separator' },
          { id: 'quit', label: 'Quit Voide', action: 'quit', shortcut: 'Cmd+Q' }
        ])
        window.craft.tray.onClickToggleWindow()
        addMessage('system', 'Running as native app - system tray enabled')
      } catch (e) {
        console.log('Native features not fully available:', e)
      }
    }

    function updateTrayStatus(status) {
      if (!state.isNativeApp || !window.craft) return
      const icons = { ready: 'ðŸ¤–', recording: 'ðŸ”´', processing: 'â³', success: 'âœ…', error: 'âŒ' }
      try {
        window.craft.tray.setTitle((icons[status] || 'ðŸ¤–') + ' Voide')
      } catch (e) {}
    }

    function sendNotification(title, body) {
      if (!state.isNativeApp || !window.craft) return
      try {
        window.craft.app.notify({ title, body })
      } catch (e) {}
    }

    // ==========================================================================
    // Modal Functions
    // ==========================================================================

    function openGithubModal() {
      modals.github = true
    }

    function closeGithubModal() {
      modals.github = false
    }

    function openSettingsModal() {
      modals.settings = true
      updateApiStatusIndicators()
    }

    function closeSettingsModal() {
      modals.settings = false
    }

    function updateApiStatusIndicators() {
      // This will be handled by reactive bindings
    }

    function saveApiSettings() {
      const anthropicInput = document.getElementById('anthropicApiKey')
      const openaiInput = document.getElementById('openaiApiKey')
      const claudeHostInput = document.getElementById('claudeCliHost')

      apiKeys.anthropic = anthropicInput?.value.trim() || null
      apiKeys.openai = openaiInput?.value.trim() || null
      apiKeys.claudeCliHost = claudeHostInput?.value.trim() || null

      localStorage.setItem('voide_api_keys', JSON.stringify(apiKeys))
      closeSettingsModal()
      addMessage('system', 'API settings saved.')
    }

    function loadSavedApiKeys() {
      try {
        const saved = localStorage.getItem('voide_api_keys')
        if (saved) {
          const parsed = JSON.parse(saved)
          Object.assign(apiKeys, parsed)
        }
      } catch (e) {}
    }

    // ==========================================================================
    // Text Input Handling
    // ==========================================================================

    function handleTextSubmit() {
      const text = message.value.trim()
      if (text && !state.isProcessing) {
        message.value = ''
        charCount.value = 0
        processCommand(text)
      }
    }

    function handleDriverChange(event) {
      state.currentDriver = event.target.value
      addMessage('system', 'Switched to ' + config.drivers[state.currentDriver].name)
    }

    // ==========================================================================
    // Lifecycle
    // ==========================================================================

    onMounted(() => {
      // Initialize native features
      initNativeFeatures()

      // Initialize speech recognition
      initSpeechRecognition()

      // Load saved data
      loadSavedApiKeys()

      const savedRepoPath = localStorage.getItem(STORAGE_KEY_REPO)
      if (savedRepoPath) {
        const repoInput = document.getElementById('repoInput')
        if (repoInput) repoInput.value = savedRepoPath
      }

      // Setup keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !e.repeat) {
          const active = document.activeElement
          const isInput = active?.tagName === 'INPUT' || active?.tagName === 'TEXTAREA'
          if (!isInput) {
            e.preventDefault()
            startRecording()
          }
        }
        if (e.key === 'Escape') {
          closeGithubModal()
          closeSettingsModal()
        }
      })

      document.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && state.isRecording) {
          e.preventDefault()
          stopRecording()
        }
      })
    })

    onUnmounted(() => {
      if (recognition) {
        try { recognition.stop() } catch (e) {}
      }
    })

    // Watch for message changes
    watch(message, (newValue) => {
      charCount.value = newValue.length
    })

    // ==========================================================================
    // Expose to window for component access
    // ==========================================================================

    window.voide = {
      state,
      messages,
      message,
      charCount,
      github,
      apiKeys,
      modals,
      config,
      currentDriverName,
      canCommit,
      canPush,
      // Methods
      addMessage,
      processCommand,
      handleRepoAction,
      commitChanges,
      pushChanges,
      startRecording,
      stopRecording,
      handleTextSubmit,
      handleDriverChange,
      openGithubModal,
      closeGithubModal,
      openSettingsModal,
      closeSettingsModal,
      saveApiSettings
    }
  </script>
</body>
</html>
