<script>
// Server-side: Static data available at build time
export const title = 'Voide'
export const version = '1.0.0'
export const apiBaseUrl = 'http://localhost:3008/voide'

export const drivers = {
  'claude-cli-local': { name: 'Claude CLI (Local)', requiresKey: null },
  'claude-cli-ec2': { name: 'Claude CLI (EC2)', requiresKey: 'BUDDY_EC2_HOST' },
  'claude': { name: 'Claude API', requiresKey: 'ANTHROPIC_API_KEY' },
  'openai': { name: 'OpenAI', requiresKey: 'OPENAI_API_KEY' },
  'ollama': { name: 'Ollama', requiresKey: null },
  'mock': { name: 'Mock', requiresKey: null }
}
</script>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>{{ title }} - Voice AI Code Assistant</title>

  <style>
    /* Custom animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }
    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }

    .animate-fade-in { animation: fadeIn 0.4s ease-out; }
    .animate-pulse { animation: pulse 2s ease-in-out infinite; }
    .animate-bounce { animation: bounce 0.6s ease-in-out infinite; }

    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }

    /* Body styling */
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    /* Gradient background with noise */
    .gradient-bg {
      background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #0f172a 100%);
      position: relative;
    }
    .gradient-bg::before {
      content: '';
      position: absolute;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
    }

    /* Floating orbs */
    .orb {
      position: absolute;
      border-radius: 50%;
      filter: blur(80px);
      opacity: 0.3;
      animation: float 20s ease-in-out infinite;
    }
    .orb-1 {
      width: 400px;
      height: 400px;
      background: linear-gradient(to right, #8b5cf6, #06b6d4);
      top: -100px;
      right: -100px;
      animation-delay: 0s;
    }
    .orb-2 {
      width: 300px;
      height: 300px;
      background: linear-gradient(to right, #ec4899, #8b5cf6);
      bottom: -50px;
      left: -50px;
      animation-delay: -10s;
    }
  </style>

  <!-- Load Headwind CSS -->
  <script>
    // Dynamically load Headwind CSS to bypass bundler
    (function() {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = '/dist/voide.css';
      link.onload = function() { document.body.style.visibility = 'visible'; };
      document.head.appendChild(link);
      // Hide body until CSS loads to prevent FOUC
      document.write('<style>body{visibility:hidden}</style>');
    })();
  </script>
</head>
<body class="gradient-bg flex flex-col h-screen text-white overflow-hidden">
  <!-- Floating orbs -->
  <div class="orb orb-1"></div>
  <div class="orb orb-2"></div>

  <!-- Header -->
  @include('./components/voide/header', { title })

  <!-- Main Content -->
  <main class="relative flex-1 flex flex-col p-6 gap-5 overflow-hidden">
    <!-- Terminal -->
    @include('./components/voide/terminal')

    <!-- Input Bar -->
    @include('./components/voide/input-bar')
  </main>

  <!-- Footer -->
  <footer class="relative px-6 py-3 text-center text-xs text-slate-500 border-t border-white/5">
    <span class="bg-gradient-to-r from-violet-400 to-cyan-400 bg-clip-text text-transparent font-medium">{{ title }}</span>
    <span class="mx-2">Â·</span>
    <span>v{{ version }}</span>
    <span class="mx-2">Â·</span>
    <span>Voice AI Code Assistant</span>
  </footer>

  <!-- Modals -->
  @include('./components/voide/modals')

  <!-- Craft Native Bridge -->
  <script>
    (function() {
      if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.craftBridge) {
        window.craft = {
          _callbacks: {},
          _callbackId: 0,
          _invoke: function(method, args) {
            args = args || {};
            var self = this;
            return new Promise(function(resolve, reject) {
              var id = ++self._callbackId;
              self._callbacks[id] = { resolve: resolve, reject: reject };
              window.webkit.messageHandlers.craftBridge.postMessage({ id: id, method: method, args: args });
            });
          },
          _handleResponse: function(id, result, error) {
            var cb = this._callbacks[id];
            if (cb) {
              delete this._callbacks[id];
              error ? cb.reject(new Error(error)) : cb.resolve(result);
            }
          },
          window: {
            setTitle: function(title) { return window.craft._invoke('window.setTitle', { title: title }); },
            close: function() { return window.craft._invoke('window.close'); },
            minimize: function() { return window.craft._invoke('window.minimize'); },
            maximize: function() { return window.craft._invoke('window.maximize'); }
          },
          tray: {
            setTitle: function(title) { return window.craft._invoke('tray.setTitle', { title: title }); },
            setTooltip: function(tooltip) { return window.craft._invoke('tray.setTooltip', { tooltip: tooltip }); },
            setMenu: function(menu) { return window.craft._invoke('tray.setMenu', { menu: menu }); },
            onClickToggleWindow: function() { return window.craft._invoke('tray.onClickToggleWindow'); }
          },
          app: {
            quit: function() { return window.craft._invoke('app.quit'); },
            notify: function(options) { return window.craft._invoke('app.notify', options); }
          }
        };
        console.log('[Voide] Craft native bridge initialized');
      }
    })();
  </script>

  <!-- Voide Client Runtime (Plain JS - No ES Modules) -->
  <script>
    (function() {
      'use strict';

      // ==========================================================================
      // State Management (Simple reactive-like state)
      // ==========================================================================

      var state = {
        isRecording: false,
        isProcessing: false,
        transcript: '',
        repoPath: '',
        hasChanges: false,
        speechSupported: false,
        currentDriver: 'claude-cli-local',
        isNativeApp: false,
        terminalTitle: 'Voide - Ready'
      };

      var messages = { value: [] };
      var message = { value: '' };
      var charCount = { value: 0 };

      var github = {
        connected: false,
        token: null,
        username: null,
        name: null,
        email: null,
        avatarUrl: null
      };

      var apiKeys = {
        anthropic: null,
        openai: null,
        claudeCliHost: null
      };

      var modals = {
        github: false,
        settings: false
      };

      var recognition = null;

      var config = {
        title: 'Voide',
        version: '1.0.0',
        apiBaseUrl: 'http://localhost:3008/voide',
        drivers: {
          'claude-cli-local': { name: 'Claude CLI (Local)', requiresKey: null },
          'claude-cli-ec2': { name: 'Claude CLI (EC2)', requiresKey: 'BUDDY_EC2_HOST' },
          'claude': { name: 'Claude API', requiresKey: 'ANTHROPIC_API_KEY' },
          'openai': { name: 'OpenAI', requiresKey: 'OPENAI_API_KEY' },
          'ollama': { name: 'Ollama', requiresKey: null },
          'mock': { name: 'Mock', requiresKey: null }
        }
      };

      var STORAGE_KEY_REPO = 'voide_last_repo_path';

      // ==========================================================================
      // Computed Properties
      // ==========================================================================

      function getCurrentDriverName() {
        var driver = config.drivers[state.currentDriver];
        return driver ? driver.name : 'AI';
      }

      // ==========================================================================
      // Methods
      // ==========================================================================

      function addMessage(type, content, header) {
        var driverName = getCurrentDriverName();
        var headerText = header || (type === 'user' ? 'You' : type === 'assistant' ? driverName : type === 'system' ? 'System' : 'Error');

        messages.value.push({
          type: type,
          content: content,
          header: headerText,
          timestamp: Date.now()
        });

        setTimeout(function() {
          var output = document.getElementById('output');
          if (output) output.scrollTop = output.scrollHeight;
        }, 10);
      }

      function checkBackendAPI() {
        return fetch(config.apiBaseUrl + '/state')
          .then(function(res) { return res.ok; })
          .catch(function() { return false; });
      }

      function processCommand(command) {
        if (!command.trim()) return;

        addMessage('user', command);
        state.terminalTitle = 'Processing...';

        if (!state.repoPath) {
          addMessage('error', 'Please enter a repository URL or path first.');
          state.terminalTitle = config.title + ' - Ready';
          return;
        }

        state.isProcessing = true;
        addMessage('assistant', '...');

        checkBackendAPI().then(function(hasBackend) {
          var responsePromise;

          if (hasBackend) {
            responsePromise = fetch(config.apiBaseUrl + '/process', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                command: command,
                driver: state.currentDriver,
                repository: state.repoPath
              })
            }).then(function(res) { return res.json(); });
          } else if (state.currentDriver === 'mock') {
            responsePromise = new Promise(function(resolve) {
              setTimeout(function() {
                resolve({
                  success: true,
                  data: {
                    message: '[Mock] Processing: "' + command + '"\n\nThis is a simulated response.',
                    hasChanges: command.toLowerCase().indexOf('fix') !== -1
                  }
                });
              }, 1500);
            });
          } else {
            responsePromise = Promise.reject(new Error('Backend API not available. Start the server at localhost:3008.'));
          }

          return responsePromise;
        }).then(function(response) {
          messages.value.pop();

          // Handle both wrapped {success, data} and direct response formats
          var data = response.data || response;
          var message = data.message;

          if (message) {
            addMessage('assistant', message);
            if (data.hasChanges) {
              state.hasChanges = true;
              addMessage('system', 'Changes staged. Click "Commit Changes" to create a commit.');
              sendNotification('Changes Ready', 'Code changes are staged.');
            }
          } else if (response.error) {
            throw new Error(response.error);
          } else {
            throw new Error('No response message');
          }

          state.terminalTitle = config.title + ' - Ready';
          updateTrayStatus('success');
          setTimeout(function() { updateTrayStatus('ready'); }, 2000);
        }).catch(function(error) {
          messages.value.pop();
          addMessage('error', 'Failed: ' + error.message);
          state.terminalTitle = config.title + ' - Error';
          updateTrayStatus('error');
          setTimeout(function() { updateTrayStatus('ready'); }, 3000);
        }).finally(function() {
          state.isProcessing = false;
        });
      }

      function handleRepoAction() {
        var input = document.getElementById('repoInput');
        var inputValue = input ? input.value.trim() : '';

        if (!inputValue) {
          addMessage('error', 'Please enter a repository URL or path.');
          return;
        }

        addMessage('system', 'Opening repository: ' + inputValue);

        checkBackendAPI().then(function(hasBackend) {
          if (hasBackend) {
            return fetch(config.apiBaseUrl + '/repo', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ input: inputValue })
            }).then(function(res) { return res.json(); });
          } else {
            return {
              success: true,
              data: {
                repo: { path: inputValue, name: inputValue.split('/').pop(), branch: 'main' }
              }
            };
          }
        }).then(function(response) {
          // Handle both wrapped {success, data} and direct response formats
          var data = response.data || response;
          var repo = data.repo;

          if (repo) {
            state.repoPath = repo.path;
            localStorage.setItem(STORAGE_KEY_REPO, repo.path);
            addMessage('system', 'Repository "' + repo.name + '" opened.\nPath: ' + repo.path + '\nBranch: ' + repo.branch);
            state.terminalTitle = config.title + ' - ' + repo.name;
          } else if (response.error) {
            throw new Error(response.error);
          } else {
            throw new Error('Failed to open repository');
          }
        }).catch(function(error) {
          addMessage('error', 'Failed: ' + error.message);
        });
      }

      function commitChanges() {
        if (!state.hasChanges) return;

        addMessage('system', 'Creating commit...');
        updateTrayStatus('processing');

        checkBackendAPI().then(function(hasBackend) {
          if (hasBackend) {
            return fetch(config.apiBaseUrl + '/commit', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            }).then(function(res) { return res.json(); });
          } else {
            return { success: true, hash: 'mock-commit-hash' };
          }
        }).then(function(response) {
          addMessage('system', 'Committed: ' + (response.hash || 'success'));
          state.hasChanges = false;
          updateTrayStatus('success');
          setTimeout(function() { updateTrayStatus('ready'); }, 2000);
        }).catch(function(error) {
          addMessage('error', 'Failed: ' + error.message);
          updateTrayStatus('error');
          setTimeout(function() { updateTrayStatus('ready'); }, 3000);
        });
      }

      function pushChanges() {
        addMessage('system', 'Pushing to remote...');
        updateTrayStatus('processing');

        checkBackendAPI().then(function(hasBackend) {
          if (hasBackend) {
            return fetch(config.apiBaseUrl + '/push', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            });
          }
          return Promise.resolve();
        }).then(function() {
          addMessage('system', 'Pushed successfully.');
          updateTrayStatus('success');
          setTimeout(function() { updateTrayStatus('ready'); }, 2000);
        }).catch(function(error) {
          addMessage('error', 'Failed: ' + error.message);
          updateTrayStatus('error');
          setTimeout(function() { updateTrayStatus('ready'); }, 3000);
        });
      }

      // ==========================================================================
      // Speech Recognition
      // ==========================================================================

      function initSpeechRecognition() {
        var SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          state.speechSupported = false;
          addMessage('system', 'Speech recognition not available. Please use text input.');
          return false;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = true;
        recognition.lang = 'en-US';
        recognition.maxAlternatives = 1;

        recognition.onstart = function() {
          state.isRecording = true;
          state.transcript = '';
          updateTrayStatus('recording');
        };

        recognition.onresult = function(event) {
          var transcript = '';
          for (var i = 0; i < event.results.length; i++) {
            transcript += event.results[i][0].transcript;
          }
          state.transcript = transcript;
        };

        recognition.onerror = function(event) {
          console.error('Speech recognition error:', event.error);
          stopRecording();
          if (event.error === 'not-allowed') {
            addMessage('error', 'Microphone access denied.');
          } else if (event.error === 'network') {
            addMessage('error', 'Speech recognition requires internet.');
          } else if (event.error !== 'aborted' && event.error !== 'no-speech') {
            addMessage('error', 'Speech error: ' + event.error);
          }
        };

        recognition.onend = function() {
          if (state.isRecording) {
            var transcript = state.transcript.trim();
            stopRecording();
            if (transcript) processCommand(transcript);
          }
        };

        state.speechSupported = true;
        return true;
      }

      function startRecording() {
        if (!state.speechSupported || state.isRecording) return;
        state.transcript = '';
        try {
          recognition.start();
        } catch (e) {
          addMessage('error', 'Failed to start voice recognition.');
        }
      }

      function stopRecording() {
        state.isRecording = false;
        updateTrayStatus('ready');
        if (recognition) {
          try { recognition.stop(); } catch (e) {}
        }
      }

      // ==========================================================================
      // Native App Features
      // ==========================================================================

      function initNativeFeatures() {
        if (!window.craft) return;

        state.isNativeApp = true;
        try {
          window.craft.tray.setTitle('Voide');
          window.craft.tray.setTooltip('Voide - Voice AI Code Assistant');
          window.craft.tray.setMenu([
            { id: 'show', label: 'Show Voide', action: 'show' },
            { id: 'hide', label: 'Hide Window', action: 'hide' },
            { type: 'separator' },
            { id: 'recording', label: 'Start Recording', action: 'startRecording' },
            { type: 'separator' },
            { id: 'quit', label: 'Quit Voide', action: 'quit', shortcut: 'Cmd+Q' }
          ]);
          window.craft.tray.onClickToggleWindow();
          addMessage('system', 'Running as native app - system tray enabled');
        } catch (e) {
          console.log('Native features not fully available:', e);
        }
      }

      function updateTrayStatus(status) {
        if (!state.isNativeApp || !window.craft) return;
        var icons = { ready: 'ðŸ¤–', recording: 'ðŸ”´', processing: 'â³', success: 'âœ…', error: 'âŒ' };
        try {
          window.craft.tray.setTitle((icons[status] || 'ðŸ¤–') + ' Voide');
        } catch (e) {}
      }

      function sendNotification(title, body) {
        if (!state.isNativeApp || !window.craft) return;
        try {
          window.craft.app.notify({ title: title, body: body });
        } catch (e) {}
      }

      // ==========================================================================
      // Modal Functions
      // ==========================================================================

      function openGithubModal() {
        modals.github = true;
      }

      function closeGithubModal() {
        modals.github = false;
      }

      function openSettingsModal() {
        modals.settings = true;
      }

      function closeSettingsModal() {
        modals.settings = false;
      }

      function saveApiSettings() {
        var anthropicInput = document.getElementById('anthropicApiKey');
        var openaiInput = document.getElementById('openaiApiKey');
        var claudeHostInput = document.getElementById('claudeCliHost');

        apiKeys.anthropic = anthropicInput ? anthropicInput.value.trim() || null : null;
        apiKeys.openai = openaiInput ? openaiInput.value.trim() || null : null;
        apiKeys.claudeCliHost = claudeHostInput ? claudeHostInput.value.trim() || null : null;

        localStorage.setItem('voide_api_keys', JSON.stringify(apiKeys));
        closeSettingsModal();
        addMessage('system', 'API settings saved.');
      }

      function loadSavedApiKeys() {
        try {
          var saved = localStorage.getItem('voide_api_keys');
          if (saved) {
            var parsed = JSON.parse(saved);
            Object.assign(apiKeys, parsed);
          }
        } catch (e) {}
      }

      // ==========================================================================
      // Text Input Handling
      // ==========================================================================

      function handleTextSubmit() {
        var text = message.value.trim();
        if (text && !state.isProcessing) {
          message.value = '';
          charCount.value = 0;
          processCommand(text);
        }
      }

      function handleDriverChange(event) {
        state.currentDriver = event.target.value;
        addMessage('system', 'Switched to ' + config.drivers[state.currentDriver].name);
      }

      // ==========================================================================
      // Initialization
      // ==========================================================================

      function init() {
        // Initialize native features
        initNativeFeatures();

        // Initialize speech recognition
        initSpeechRecognition();

        // Load saved data
        loadSavedApiKeys();

        var savedRepoPath = localStorage.getItem(STORAGE_KEY_REPO);
        if (savedRepoPath) {
          var repoInput = document.getElementById('repoInput');
          if (repoInput) repoInput.value = savedRepoPath;
        }

        // Setup keyboard shortcuts
        document.addEventListener('keydown', function(e) {
          if (e.code === 'Space' && !e.repeat) {
            var active = document.activeElement;
            var isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
            if (!isInput) {
              e.preventDefault();
              startRecording();
            }
          }
          if (e.key === 'Escape') {
            closeGithubModal();
            closeSettingsModal();
          }
        });

        document.addEventListener('keyup', function(e) {
          if (e.code === 'Space' && state.isRecording) {
            e.preventDefault();
            stopRecording();
          }
        });
      }

      // ==========================================================================
      // Expose to window for component access
      // ==========================================================================

      window.voide = {
        state: state,
        messages: messages,
        message: message,
        charCount: charCount,
        github: github,
        apiKeys: apiKeys,
        modals: modals,
        config: config,
        getCurrentDriverName: getCurrentDriverName,
        // Methods
        addMessage: addMessage,
        processCommand: processCommand,
        handleRepoAction: handleRepoAction,
        commitChanges: commitChanges,
        pushChanges: pushChanges,
        startRecording: startRecording,
        stopRecording: stopRecording,
        handleTextSubmit: handleTextSubmit,
        handleDriverChange: handleDriverChange,
        openGithubModal: openGithubModal,
        closeGithubModal: closeGithubModal,
        openSettingsModal: openSettingsModal,
        closeSettingsModal: closeSettingsModal,
        saveApiSettings: saveApiSettings
      };

      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
