<script>
// Server-side: Static data available at build time
export const title = 'Voide'
export const version = '1.0.0'
export const apiBaseUrl = 'http://localhost:3008/voide'

export const drivers = {
  'claude-cli-local': { name: 'Claude CLI (Local)', requiresKey: null },
  'claude-cli-ec2': { name: 'Claude CLI (EC2)', requiresKey: 'BUDDY_EC2_HOST' },
  'claude': { name: 'Claude API', requiresKey: 'ANTHROPIC_API_KEY' },
  'openai': { name: 'OpenAI', requiresKey: 'OPENAI_API_KEY' },
  'ollama': { name: 'Ollama', requiresKey: null },
  'mock': { name: 'Mock', requiresKey: null }
}
</script>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>{{ title }} - Voice AI Code Assistant</title>

  <style>
    /* Custom animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }
    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }

    .animate-fade-in { animation: fadeIn 0.4s ease-out; }
    .animate-pulse { animation: pulse 2s ease-in-out infinite; }
    .animate-bounce { animation: bounce 0.6s ease-in-out infinite; }

    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }

    /* Body styling */
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    /* Gradient background with noise */
    .gradient-bg {
      background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #0f172a 100%);
      position: relative;
    }
    .gradient-bg::before {
      content: '';
      position: absolute;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
    }

    /* Floating orbs */
    .orb {
      position: absolute;
      border-radius: 50%;
      filter: blur(80px);
      opacity: 0.3;
      animation: float 20s ease-in-out infinite;
    }
    .orb-1 {
      width: 400px;
      height: 400px;
      background: linear-gradient(to right, #8b5cf6, #06b6d4);
      top: -100px;
      right: -100px;
      animation-delay: 0s;
    }
    .orb-2 {
      width: 300px;
      height: 300px;
      background: linear-gradient(to right, #ec4899, #8b5cf6);
      bottom: -50px;
      left: -50px;
      animation-delay: -10s;
    }
  </style>

  <!-- Load Headwind CSS -->
  <script>
    // Dynamically load Headwind CSS to bypass bundler
    (function() {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = '/dist/voide.css';
      link.onload = function() { document.body.style.visibility = 'visible'; };
      document.head.appendChild(link);
      // Hide body until CSS loads to prevent FOUC
      document.write('<style>body{visibility:hidden}</style>');
    })();
  </script>
</head>
<body class="gradient-bg flex flex-col h-screen text-white overflow-hidden">
  <!-- Floating orbs -->
  <div class="orb orb-1"></div>
  <div class="orb orb-2"></div>

  <!-- Header -->
  @include('./components/voide/header', { title })

  <!-- Main Content -->
  <main class="relative flex-1 flex flex-col p-6 gap-5 overflow-hidden">
    <!-- Terminal -->
    @include('./components/voide/terminal')

    <!-- Input Bar -->
    @include('./components/voide/input-bar')
  </main>

  <!-- Footer -->
  <footer class="relative px-6 py-3 text-center text-xs text-slate-500 border-t border-white/5">
    <span class="bg-gradient-to-r from-violet-400 to-cyan-400 bg-clip-text text-transparent font-medium">{{ title }}</span>
    <span class="mx-2">Â·</span>
    <span>v{{ version }}</span>
    <span class="mx-2">Â·</span>
    <span>Voice AI Code Assistant</span>
  </footer>

  <!-- Modals -->
  @include('./components/voide/modals')

  <!-- Craft Native Bridge -->
  <script>
    (function() {
      if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.craftBridge) {
        window.craft = {
          _callbacks: {},
          _callbackId: 0,
          _invoke: function(method, args) {
            args = args || {};
            var self = this;
            return new Promise(function(resolve, reject) {
              var id = ++self._callbackId;
              self._callbacks[id] = { resolve: resolve, reject: reject };
              window.webkit.messageHandlers.craftBridge.postMessage({ id: id, method: method, args: args });
            });
          },
          _handleResponse: function(id, result, error) {
            var cb = this._callbacks[id];
            if (cb) {
              delete this._callbacks[id];
              error ? cb.reject(new Error(error)) : cb.resolve(result);
            }
          },
          window: {
            setTitle: function(title) { return window.craft._invoke('window.setTitle', { title: title }); },
            close: function() { return window.craft._invoke('window.close'); },
            minimize: function() { return window.craft._invoke('window.minimize'); },
            maximize: function() { return window.craft._invoke('window.maximize'); }
          },
          tray: {
            setTitle: function(title) { return window.craft._invoke('tray.setTitle', { title: title }); },
            setTooltip: function(tooltip) { return window.craft._invoke('tray.setTooltip', { tooltip: tooltip }); },
            setMenu: function(menu) { return window.craft._invoke('tray.setMenu', { menu: menu }); },
            onClickToggleWindow: function() { return window.craft._invoke('tray.onClickToggleWindow'); }
          },
          app: {
            quit: function() { return window.craft._invoke('app.quit'); },
            notify: function(options) { return window.craft._invoke('app.notify', options); }
          }
        };
        console.log('[Voide] Craft native bridge initialized');
      }
    })();
  </script>

  <!-- STX Client Runtime -->
  <script client>
    import { ref, reactive, computed, onMounted, onUnmounted, watch } from 'stx'

    // ==========================================================================
    // Reactive State
    // ==========================================================================

    const state = reactive({
      isRecording: false,
      isProcessing: false,
      transcript: '',
      repoPath: '',
      hasChanges: false,
      speechSupported: false,
      currentDriver: 'claude-cli-local',
      isNativeApp: false,
      terminalTitle: 'Voide - Ready'
    })

    const messages = ref([])
    const message = ref('')
    const charCount = ref(0)

    const github = reactive({
      connected: false,
      token: null,
      username: null,
      name: null,
      email: null,
      avatarUrl: null
    })

    const apiKeys = reactive({
      anthropic: null,
      openai: null,
      claudeCliHost: null
    })

    const modals = reactive({
      github: false,
      settings: false
    })

    // Speech recognition instance
    let recognition = null

    // Config
    const config = {
      title: 'Voide',
      version: '1.0.0',
      apiBaseUrl: 'http://localhost:3008/voide',
      drivers: {
        'claude-cli-local': { name: 'Claude CLI (Local)', requiresKey: null },
        'claude-cli-ec2': { name: 'Claude CLI (EC2)', requiresKey: 'BUDDY_EC2_HOST' },
        'claude': { name: 'Claude API', requiresKey: 'ANTHROPIC_API_KEY' },
        'openai': { name: 'OpenAI', requiresKey: 'OPENAI_API_KEY' },
        'ollama': { name: 'Ollama', requiresKey: null },
        'mock': { name: 'Mock', requiresKey: null }
      }
    }

    const STORAGE_KEY_REPO = 'voide_last_repo_path'

    // ==========================================================================
    // Computed Properties
    // ==========================================================================

    const currentDriverName = computed(() => {
      return config.drivers[state.currentDriver]?.name || 'AI'
    })

    const canCommit = computed(() => {
      return state.hasChanges && !state.isProcessing
    })

    const canPush = computed(() => {
      return state.hasChanges && !state.isProcessing
    })

    // ==========================================================================
    // Methods
    // ==========================================================================

    function escapeHtml(text) {
      const div = document.createElement('div')
      div.textContent = text
      return div.innerHTML
    }

    function addMessage(type, content, header) {
      const driverName = currentDriverName.value
      const headerText = header || (type === 'user' ? 'You' : type === 'assistant' ? driverName : type === 'system' ? 'System' : 'Error')

      messages.value.push({
        type,
        content,
        header: headerText,
        timestamp: Date.now()
      })

      // Scroll to bottom
      setTimeout(() => {
        const output = document.getElementById('output')
        if (output) output.scrollTop = output.scrollHeight
      }, 10)
    }

    async function checkBackendAPI() {
      try {
        const res = await fetch(config.apiBaseUrl + '/state')
        return res.ok
      } catch {
        return false
      }
    }

    async function processCommand(command) {
      if (!command.trim()) return

      addMessage('user', command)
      state.terminalTitle = 'Processing...'

      if (!state.repoPath) {
        addMessage('error', 'Please enter a repository URL or path first.')
        state.terminalTitle = config.title + ' - Ready'
        return
      }

      state.isProcessing = true
      addMessage('assistant', '...')  // Loading indicator

      try {
        const hasBackend = await checkBackendAPI()
        let response

        if (hasBackend) {
          const res = await fetch(config.apiBaseUrl + '/process', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              command,
              driver: state.currentDriver,
              repository: state.repoPath
            })
          })
          response = await res.json()
        } else if (state.currentDriver === 'mock') {
          await new Promise(resolve => setTimeout(resolve, 1500))
          response = {
            success: true,
            data: {
              message: `[Mock] Processing: "${command}"\n\nThis is a simulated response.`,
              hasChanges: command.toLowerCase().includes('fix')
            }
          }
        } else {
          throw new Error('Backend API not available. Start the server at localhost:3008.')
        }

        // Remove loading message
        messages.value.pop()

        if (response.success && response.data) {
          addMessage('assistant', response.data.message)
          if (response.data.hasChanges) {
            state.hasChanges = true
            addMessage('system', 'Changes staged. Click "Commit Changes" to create a commit.')
            sendNotification('Changes Ready', 'Code changes are staged.')
          }
        } else {
          throw new Error(response.error || 'Unknown error')
        }

        state.terminalTitle = config.title + ' - Ready'
        updateTrayStatus('success')
        setTimeout(() => updateTrayStatus('ready'), 2000)

      } catch (error) {
        messages.value.pop()  // Remove loading
        addMessage('error', 'Failed: ' + error.message)
        state.terminalTitle = config.title + ' - Error'
        updateTrayStatus('error')
        setTimeout(() => updateTrayStatus('ready'), 3000)
      } finally {
        state.isProcessing = false
      }
    }

    async function handleRepoAction() {
      const input = document.getElementById('repoInput')?.value.trim()
      if (!input) {
        addMessage('error', 'Please enter a repository URL or path.')
        return
      }

      addMessage('system', 'Opening repository: ' + input)

      try {
        const hasBackend = await checkBackendAPI()
        let response

        if (hasBackend) {
          const res = await fetch(config.apiBaseUrl + '/repo', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input })
          })
          response = await res.json()
        } else {
          response = {
            success: true,
            data: {
              repo: { path: input, name: input.split('/').pop(), branch: 'main' }
            }
          }
        }

        if (response.success && response.data?.repo) {
          const repo = response.data.repo
          state.repoPath = repo.path
          localStorage.setItem(STORAGE_KEY_REPO, repo.path)
          addMessage('system', `Repository "${repo.name}" opened.\nPath: ${repo.path}\nBranch: ${repo.branch}`)
          state.terminalTitle = config.title + ' - ' + repo.name
        } else {
          throw new Error(response.error || 'Failed to open repository')
        }
      } catch (error) {
        addMessage('error', 'Failed: ' + error.message)
      }
    }

    async function commitChanges() {
      if (!state.hasChanges) return

      addMessage('system', 'Creating commit...')
      updateTrayStatus('processing')

      try {
        const hasBackend = await checkBackendAPI()
        let response

        if (hasBackend) {
          const res = await fetch(config.apiBaseUrl + '/commit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
          response = await res.json()
        } else {
          response = { success: true, hash: 'mock-commit-hash' }
        }

        addMessage('system', 'Committed: ' + (response.hash || 'success'))
        state.hasChanges = false
        updateTrayStatus('success')
        setTimeout(() => updateTrayStatus('ready'), 2000)
      } catch (error) {
        addMessage('error', 'Failed: ' + error.message)
        updateTrayStatus('error')
        setTimeout(() => updateTrayStatus('ready'), 3000)
      }
    }

    async function pushChanges() {
      addMessage('system', 'Pushing to remote...')
      updateTrayStatus('processing')

      try {
        const hasBackend = await checkBackendAPI()
        if (hasBackend) {
          await fetch(config.apiBaseUrl + '/push', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
        }

        addMessage('system', 'Pushed successfully.')
        updateTrayStatus('success')
        setTimeout(() => updateTrayStatus('ready'), 2000)
      } catch (error) {
        addMessage('error', 'Failed: ' + error.message)
        updateTrayStatus('error')
        setTimeout(() => updateTrayStatus('ready'), 3000)
      }
    }

    // ==========================================================================
    // Speech Recognition
    // ==========================================================================

    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition
      if (!SpeechRecognition) {
        state.speechSupported = false
        addMessage('system', 'Speech recognition not available. Please use text input.')
        return false
      }

      recognition = new SpeechRecognition()
      recognition.continuous = false
      recognition.interimResults = true
      recognition.lang = 'en-US'
      recognition.maxAlternatives = 1

      recognition.onstart = () => {
        state.isRecording = true
        state.transcript = ''
        updateTrayStatus('recording')
      }

      recognition.onresult = (event) => {
        let transcript = ''
        for (let i = 0; i < event.results.length; i++) {
          transcript += event.results[i][0].transcript
        }
        state.transcript = transcript
      }

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error)
        stopRecording()
        if (event.error === 'not-allowed') {
          addMessage('error', 'Microphone access denied.')
        } else if (event.error === 'network') {
          addMessage('error', 'Speech recognition requires internet.')
        } else if (event.error !== 'aborted' && event.error !== 'no-speech') {
          addMessage('error', 'Speech error: ' + event.error)
        }
      }

      recognition.onend = () => {
        if (state.isRecording) {
          const transcript = state.transcript.trim()
          stopRecording()
          if (transcript) processCommand(transcript)
        }
      }

      state.speechSupported = true
      return true
    }

    function startRecording() {
      if (!state.speechSupported || state.isRecording) return
      state.transcript = ''
      try {
        recognition.start()
      } catch (e) {
        addMessage('error', 'Failed to start voice recognition.')
      }
    }

    function stopRecording() {
      state.isRecording = false
      updateTrayStatus('ready')
      if (recognition) {
        try { recognition.stop() } catch (e) {}
      }
    }

    // ==========================================================================
    // Native App Features
    // ==========================================================================

    function initNativeFeatures() {
      if (!window.craft) return

      state.isNativeApp = true
      try {
        window.craft.tray.setTitle('Voide')
        window.craft.tray.setTooltip('Voide - Voice AI Code Assistant')
        window.craft.tray.setMenu([
          { id: 'show', label: 'Show Voide', action: 'show' },
          { id: 'hide', label: 'Hide Window', action: 'hide' },
          { type: 'separator' },
          { id: 'recording', label: 'Start Recording', action: 'startRecording' },
          { type: 'separator' },
          { id: 'quit', label: 'Quit Voide', action: 'quit', shortcut: 'Cmd+Q' }
        ])
        window.craft.tray.onClickToggleWindow()
        addMessage('system', 'Running as native app - system tray enabled')
      } catch (e) {
        console.log('Native features not fully available:', e)
      }
    }

    function updateTrayStatus(status) {
      if (!state.isNativeApp || !window.craft) return
      const icons = { ready: 'ðŸ¤–', recording: 'ðŸ”´', processing: 'â³', success: 'âœ…', error: 'âŒ' }
      try {
        window.craft.tray.setTitle((icons[status] || 'ðŸ¤–') + ' Voide')
      } catch (e) {}
    }

    function sendNotification(title, body) {
      if (!state.isNativeApp || !window.craft) return
      try {
        window.craft.app.notify({ title, body })
      } catch (e) {}
    }

    // ==========================================================================
    // Modal Functions
    // ==========================================================================

    function openGithubModal() {
      modals.github = true
    }

    function closeGithubModal() {
      modals.github = false
    }

    function openSettingsModal() {
      modals.settings = true
      updateApiStatusIndicators()
    }

    function closeSettingsModal() {
      modals.settings = false
    }

    function updateApiStatusIndicators() {
      // This will be handled by reactive bindings
    }

    function saveApiSettings() {
      const anthropicInput = document.getElementById('anthropicApiKey')
      const openaiInput = document.getElementById('openaiApiKey')
      const claudeHostInput = document.getElementById('claudeCliHost')

      apiKeys.anthropic = anthropicInput?.value.trim() || null
      apiKeys.openai = openaiInput?.value.trim() || null
      apiKeys.claudeCliHost = claudeHostInput?.value.trim() || null

      localStorage.setItem('voide_api_keys', JSON.stringify(apiKeys))
      closeSettingsModal()
      addMessage('system', 'API settings saved.')
    }

    function loadSavedApiKeys() {
      try {
        const saved = localStorage.getItem('voide_api_keys')
        if (saved) {
          const parsed = JSON.parse(saved)
          Object.assign(apiKeys, parsed)
        }
      } catch (e) {}
    }

    // ==========================================================================
    // Text Input Handling
    // ==========================================================================

    function handleTextSubmit() {
      const text = message.value.trim()
      if (text && !state.isProcessing) {
        message.value = ''
        charCount.value = 0
        processCommand(text)
      }
    }

    function handleDriverChange(event) {
      state.currentDriver = event.target.value
      addMessage('system', 'Switched to ' + config.drivers[state.currentDriver].name)
    }

    // ==========================================================================
    // Lifecycle
    // ==========================================================================

    onMounted(() => {
      // Initialize native features
      initNativeFeatures()

      // Initialize speech recognition
      initSpeechRecognition()

      // Load saved data
      loadSavedApiKeys()

      const savedRepoPath = localStorage.getItem(STORAGE_KEY_REPO)
      if (savedRepoPath) {
        const repoInput = document.getElementById('repoInput')
        if (repoInput) repoInput.value = savedRepoPath
      }

      // Setup keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !e.repeat) {
          const active = document.activeElement
          const isInput = active?.tagName === 'INPUT' || active?.tagName === 'TEXTAREA'
          if (!isInput) {
            e.preventDefault()
            startRecording()
          }
        }
        if (e.key === 'Escape') {
          closeGithubModal()
          closeSettingsModal()
        }
      })

      document.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && state.isRecording) {
          e.preventDefault()
          stopRecording()
        }
      })
    })

    onUnmounted(() => {
      if (recognition) {
        try { recognition.stop() } catch (e) {}
      }
    })

    // Watch for message changes
    watch(message, (newValue) => {
      charCount.value = newValue.length
    })

    // ==========================================================================
    // Expose to window for component access
    // ==========================================================================

    window.voide = {
      state,
      messages,
      message,
      charCount,
      github,
      apiKeys,
      modals,
      config,
      currentDriverName,
      canCommit,
      canPush,
      // Methods
      addMessage,
      processCommand,
      handleRepoAction,
      commitChanges,
      pushChanges,
      startRecording,
      stopRecording,
      handleTextSubmit,
      handleDriverChange,
      openGithubModal,
      closeGithubModal,
      openSettingsModal,
      closeSettingsModal,
      saveApiSettings
    }
  </script>
</body>
</html>
